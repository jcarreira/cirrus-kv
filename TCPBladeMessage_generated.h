// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TCPBLADEMESSAGE_CIRRUS_MESSAGE_TCPBLADEMESSAGE_H_
#define FLATBUFFERS_GENERATED_TCPBLADEMESSAGE_CIRRUS_MESSAGE_TCPBLADEMESSAGE_H_

#include "flatbuffers/flatbuffers.h"

namespace cirrus {
namespace message {
namespace TCPBladeMessage {

struct Write;

struct WriteAck;

struct Read;

struct ReadAck;

struct Remove;

struct RemoveAck;

struct TCPBladeMessage;

enum Message {
  Message_NONE = 0,
  Message_Write = 1,
  Message_WriteAck = 2,
  Message_Read = 3,
  Message_ReadAck = 4,
  Message_Remove = 5,
  Message_RemoveAck = 6,
  Message_MIN = Message_NONE,
  Message_MAX = Message_RemoveAck
};

inline const char **EnumNamesMessage() {
  static const char *names[] = {
    "NONE",
    "Write",
    "WriteAck",
    "Read",
    "ReadAck",
    "Remove",
    "RemoveAck",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessage(Message e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMessage()[index];
}

template<typename T> struct MessageTraits {
  static const Message enum_value = Message_NONE;
};

template<> struct MessageTraits<Write> {
  static const Message enum_value = Message_Write;
};

template<> struct MessageTraits<WriteAck> {
  static const Message enum_value = Message_WriteAck;
};

template<> struct MessageTraits<Read> {
  static const Message enum_value = Message_Read;
};

template<> struct MessageTraits<ReadAck> {
  static const Message enum_value = Message_ReadAck;
};

template<> struct MessageTraits<Remove> {
  static const Message enum_value = Message_Remove;
};

template<> struct MessageTraits<RemoveAck> {
  static const Message enum_value = Message_RemoveAck;
};

bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type);
bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Write FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_DATA = 6
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  const flatbuffers::Vector<int8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.EndTable();
  }
};

struct WriteBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Write::VT_ID, id, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<int8_t>> data) {
    fbb_.AddOffset(Write::VT_DATA, data);
  }
  WriteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WriteBuilder &operator=(const WriteBuilder &);
  flatbuffers::Offset<Write> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Write>(end);
    return o;
  }
};

inline flatbuffers::Offset<Write> CreateWrite(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> data = 0) {
  WriteBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<Write> CreateWriteDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    const std::vector<int8_t> *data = nullptr) {
  return cirrus::message::TCPBladeMessage::CreateWrite(
      _fbb,
      id,
      data ? _fbb.CreateVector<int8_t>(*data) : 0);
}

struct WriteAck FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct WriteAckBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(WriteAck::VT_ID, id, 0);
  }
  WriteAckBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WriteAckBuilder &operator=(const WriteAckBuilder &);
  flatbuffers::Offset<WriteAck> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<WriteAck>(end);
    return o;
  }
};

inline flatbuffers::Offset<WriteAck> CreateWriteAck(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0) {
  WriteAckBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct Read FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct ReadBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Read::VT_ID, id, 0);
  }
  ReadBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReadBuilder &operator=(const ReadBuilder &);
  flatbuffers::Offset<Read> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Read>(end);
    return o;
  }
};

inline flatbuffers::Offset<Read> CreateRead(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0) {
  ReadBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct ReadAck FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_DATA = 6
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  const flatbuffers::Vector<int8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.EndTable();
  }
};

struct ReadAckBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(ReadAck::VT_ID, id, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<int8_t>> data) {
    fbb_.AddOffset(ReadAck::VT_DATA, data);
  }
  ReadAckBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReadAckBuilder &operator=(const ReadAckBuilder &);
  flatbuffers::Offset<ReadAck> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<ReadAck>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReadAck> CreateReadAck(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> data = 0) {
  ReadAckBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReadAck> CreateReadAckDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    const std::vector<int8_t> *data = nullptr) {
  return cirrus::message::TCPBladeMessage::CreateReadAck(
      _fbb,
      id,
      data ? _fbb.CreateVector<int8_t>(*data) : 0);
}

struct Remove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct RemoveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Remove::VT_ID, id, 0);
  }
  RemoveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RemoveBuilder &operator=(const RemoveBuilder &);
  flatbuffers::Offset<Remove> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Remove>(end);
    return o;
  }
};

inline flatbuffers::Offset<Remove> CreateRemove(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0) {
  RemoveBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct RemoveAck FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID) &&
           verifier.EndTable();
  }
};

struct RemoveAckBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(RemoveAck::VT_ID, id, 0);
  }
  RemoveAckBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RemoveAckBuilder &operator=(const RemoveAckBuilder &);
  flatbuffers::Offset<RemoveAck> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<RemoveAck>(end);
    return o;
  }
};

inline flatbuffers::Offset<RemoveAck> CreateRemoveAck(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0) {
  RemoveAckBuilder builder_(_fbb);
  builder_.add_id(id);
  return builder_.Finish();
}

struct TCPBladeMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MESSAGE_TYPE = 4,
    VT_MESSAGE = 6
  };
  Message message_type() const {
    return static_cast<Message>(GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
  }
  const void *message() const {
    return GetPointer<const void *>(VT_MESSAGE);
  }
  template<typename T> const T *message_as() const;
  const Write *message_as_Write() const {
    return message_type() == Message_Write ? static_cast<const Write *>(message()) : nullptr;
  }
  const WriteAck *message_as_WriteAck() const {
    return message_type() == Message_WriteAck ? static_cast<const WriteAck *>(message()) : nullptr;
  }
  const Read *message_as_Read() const {
    return message_type() == Message_Read ? static_cast<const Read *>(message()) : nullptr;
  }
  const ReadAck *message_as_ReadAck() const {
    return message_type() == Message_ReadAck ? static_cast<const ReadAck *>(message()) : nullptr;
  }
  const Remove *message_as_Remove() const {
    return message_type() == Message_Remove ? static_cast<const Remove *>(message()) : nullptr;
  }
  const RemoveAck *message_as_RemoveAck() const {
    return message_type() == Message_RemoveAck ? static_cast<const RemoveAck *>(message()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           VerifyMessage(verifier, message(), message_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Write *TCPBladeMessage::message_as<Write>() const {
  return message_as_Write();
}

template<> inline const WriteAck *TCPBladeMessage::message_as<WriteAck>() const {
  return message_as_WriteAck();
}

template<> inline const Read *TCPBladeMessage::message_as<Read>() const {
  return message_as_Read();
}

template<> inline const ReadAck *TCPBladeMessage::message_as<ReadAck>() const {
  return message_as_ReadAck();
}

template<> inline const Remove *TCPBladeMessage::message_as<Remove>() const {
  return message_as_Remove();
}

template<> inline const RemoveAck *TCPBladeMessage::message_as<RemoveAck>() const {
  return message_as_RemoveAck();
}

struct TCPBladeMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_message_type(Message message_type) {
    fbb_.AddElement<uint8_t>(TCPBladeMessage::VT_MESSAGE_TYPE, static_cast<uint8_t>(message_type), 0);
  }
  void add_message(flatbuffers::Offset<void> message) {
    fbb_.AddOffset(TCPBladeMessage::VT_MESSAGE, message);
  }
  TCPBladeMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TCPBladeMessageBuilder &operator=(const TCPBladeMessageBuilder &);
  flatbuffers::Offset<TCPBladeMessage> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<TCPBladeMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<TCPBladeMessage> CreateTCPBladeMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    Message message_type = Message_NONE,
    flatbuffers::Offset<void> message = 0) {
  TCPBladeMessageBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_message_type(message_type);
  return builder_.Finish();
}

inline bool VerifyMessage(flatbuffers::Verifier &verifier, const void *obj, Message type) {
  switch (type) {
    case Message_NONE: {
      return true;
    }
    case Message_Write: {
      auto ptr = reinterpret_cast<const Write *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_WriteAck: {
      auto ptr = reinterpret_cast<const WriteAck *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Read: {
      auto ptr = reinterpret_cast<const Read *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_ReadAck: {
      auto ptr = reinterpret_cast<const ReadAck *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_Remove: {
      auto ptr = reinterpret_cast<const Remove *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Message_RemoveAck: {
      auto ptr = reinterpret_cast<const RemoveAck *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyMessageVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessage(
        verifier,  values->Get(i), types->GetEnum<Message>(i))) {
      return false;
    }
  }
  return true;
}

inline const cirrus::message::TCPBladeMessage::TCPBladeMessage *GetTCPBladeMessage(const void *buf) {
  return flatbuffers::GetRoot<cirrus::message::TCPBladeMessage::TCPBladeMessage>(buf);
}

inline bool VerifyTCPBladeMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<cirrus::message::TCPBladeMessage::TCPBladeMessage>(nullptr);
}

inline void FinishTCPBladeMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<cirrus::message::TCPBladeMessage::TCPBladeMessage> root) {
  fbb.Finish(root);
}

}  // namespace TCPBladeMessage
}  // namespace message
}  // namespace cirrus

#endif  // FLATBUFFERS_GENERATED_TCPBLADEMESSAGE_CIRRUS_MESSAGE_TCPBLADEMESSAGE_H_
