// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ALLOCATORMESSAGE_CIRRUS_MESSAGE_ALLOCATORMESSAGE_H_
#define FLATBUFFERS_GENERATED_ALLOCATORMESSAGE_CIRRUS_MESSAGE_ALLOCATORMESSAGE_H_

#include "flatbuffers/flatbuffers.h"

namespace cirrus {
namespace message {
namespace AllocatorMessage {

struct Auth1;

struct AuthAck1;

struct Auth2;

struct AuthAck2;

struct Stats;

struct StatsAck;

struct Alloc;

struct AllocAck;

struct AllocatorMessage;

enum Data {
  Data_NONE = 0,
  Data_Auth1 = 1,
  Data_AuthAck1 = 2,
  Data_Auth2 = 3,
  Data_AuthAck2 = 4,
  Data_Stats = 5,
  Data_StatsAck = 6,
  Data_Alloc = 7,
  Data_AllocAck = 8,
  Data_MIN = Data_NONE,
  Data_MAX = Data_AllocAck
};

inline const char **EnumNamesData() {
  static const char *names[] = {
    "NONE",
    "Auth1",
    "AuthAck1",
    "Auth2",
    "AuthAck2",
    "Stats",
    "StatsAck",
    "Alloc",
    "AllocAck",
    nullptr
  };
  return names;
}

inline const char *EnumNameData(Data e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesData()[index];
}

template<typename T> struct DataTraits {
  static const Data enum_value = Data_NONE;
};

template<> struct DataTraits<Auth1> {
  static const Data enum_value = Data_Auth1;
};

template<> struct DataTraits<AuthAck1> {
  static const Data enum_value = Data_AuthAck1;
};

template<> struct DataTraits<Auth2> {
  static const Data enum_value = Data_Auth2;
};

template<> struct DataTraits<AuthAck2> {
  static const Data enum_value = Data_AuthAck2;
};

template<> struct DataTraits<Stats> {
  static const Data enum_value = Data_Stats;
};

template<> struct DataTraits<StatsAck> {
  static const Data enum_value = Data_StatsAck;
};

template<> struct DataTraits<Alloc> {
  static const Data enum_value = Data_Alloc;
};

template<> struct DataTraits<AllocAck> {
  static const Data enum_value = Data_AllocAck;
};

bool VerifyData(flatbuffers::Verifier &verifier, const void *obj, Data type);
bool VerifyDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Auth1 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_APP_ID = 4
  };
  uint64_t app_id() const {
    return GetField<uint64_t>(VT_APP_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_APP_ID) &&
           verifier.EndTable();
  }
};

struct Auth1Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_app_id(uint64_t app_id) {
    fbb_.AddElement<uint64_t>(Auth1::VT_APP_ID, app_id, 0);
  }
  Auth1Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Auth1Builder &operator=(const Auth1Builder &);
  flatbuffers::Offset<Auth1> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Auth1>(end);
    return o;
  }
};

inline flatbuffers::Offset<Auth1> CreateAuth1(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t app_id = 0) {
  Auth1Builder builder_(_fbb);
  builder_.add_app_id(app_id);
  return builder_.Finish();
}

struct AuthAck1 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ALLOW = 4,
    VT_CHALLENGE = 6
  };
  int8_t allow() const {
    return GetField<int8_t>(VT_ALLOW, 0);
  }
  int64_t challenge() const {
    return GetField<int64_t>(VT_CHALLENGE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ALLOW) &&
           VerifyField<int64_t>(verifier, VT_CHALLENGE) &&
           verifier.EndTable();
  }
};

struct AuthAck1Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_allow(int8_t allow) {
    fbb_.AddElement<int8_t>(AuthAck1::VT_ALLOW, allow, 0);
  }
  void add_challenge(int64_t challenge) {
    fbb_.AddElement<int64_t>(AuthAck1::VT_CHALLENGE, challenge, 0);
  }
  AuthAck1Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AuthAck1Builder &operator=(const AuthAck1Builder &);
  flatbuffers::Offset<AuthAck1> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<AuthAck1>(end);
    return o;
  }
};

inline flatbuffers::Offset<AuthAck1> CreateAuthAck1(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t allow = 0,
    int64_t challenge = 0) {
  AuthAck1Builder builder_(_fbb);
  builder_.add_challenge(challenge);
  builder_.add_allow(allow);
  return builder_.Finish();
}

struct Auth2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RESPONSE = 4
  };
  uint64_t response() const {
    return GetField<uint64_t>(VT_RESPONSE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_RESPONSE) &&
           verifier.EndTable();
  }
};

struct Auth2Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_response(uint64_t response) {
    fbb_.AddElement<uint64_t>(Auth2::VT_RESPONSE, response, 0);
  }
  Auth2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Auth2Builder &operator=(const Auth2Builder &);
  flatbuffers::Offset<Auth2> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Auth2>(end);
    return o;
  }
};

inline flatbuffers::Offset<Auth2> CreateAuth2(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t response = 0) {
  Auth2Builder builder_(_fbb);
  builder_.add_response(response);
  return builder_.Finish();
}

struct AuthAck2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ALLOW = 4
  };
  int8_t allow() const {
    return GetField<int8_t>(VT_ALLOW, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ALLOW) &&
           verifier.EndTable();
  }
};

struct AuthAck2Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_allow(int8_t allow) {
    fbb_.AddElement<int8_t>(AuthAck2::VT_ALLOW, allow, 0);
  }
  AuthAck2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AuthAck2Builder &operator=(const AuthAck2Builder &);
  flatbuffers::Offset<AuthAck2> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<AuthAck2>(end);
    return o;
  }
};

inline flatbuffers::Offset<AuthAck2> CreateAuthAck2(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t allow = 0) {
  AuthAck2Builder builder_(_fbb);
  builder_.add_allow(allow);
  return builder_.Finish();
}

struct Stats FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct StatsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  StatsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StatsBuilder &operator=(const StatsBuilder &);
  flatbuffers::Offset<Stats> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<Stats>(end);
    return o;
  }
};

inline flatbuffers::Offset<Stats> CreateStats(
    flatbuffers::FlatBufferBuilder &_fbb) {
  StatsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct StatsAck FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TOTAL_MEM_ALLOCATED = 4
  };
  uint64_t total_mem_allocated() const {
    return GetField<uint64_t>(VT_TOTAL_MEM_ALLOCATED, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TOTAL_MEM_ALLOCATED) &&
           verifier.EndTable();
  }
};

struct StatsAckBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_total_mem_allocated(uint64_t total_mem_allocated) {
    fbb_.AddElement<uint64_t>(StatsAck::VT_TOTAL_MEM_ALLOCATED, total_mem_allocated, 0);
  }
  StatsAckBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StatsAckBuilder &operator=(const StatsAckBuilder &);
  flatbuffers::Offset<StatsAck> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<StatsAck>(end);
    return o;
  }
};

inline flatbuffers::Offset<StatsAck> CreateStatsAck(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t total_mem_allocated = 0) {
  StatsAckBuilder builder_(_fbb);
  builder_.add_total_mem_allocated(total_mem_allocated);
  return builder_.Finish();
}

struct Alloc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AllocBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  AllocBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AllocBuilder &operator=(const AllocBuilder &);
  flatbuffers::Offset<Alloc> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<Alloc>(end);
    return o;
  }
};

inline flatbuffers::Offset<Alloc> CreateAlloc(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AllocBuilder builder_(_fbb);
  return builder_.Finish();
}

struct AllocAck FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AllocAckBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  AllocAckBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AllocAckBuilder &operator=(const AllocAckBuilder &);
  flatbuffers::Offset<AllocAck> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<AllocAck>(end);
    return o;
  }
};

inline flatbuffers::Offset<AllocAck> CreateAllocAck(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AllocAckBuilder builder_(_fbb);
  return builder_.Finish();
}

struct AllocatorMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_DATA_TYPE = 6,
    VT_DATA = 8
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  Data data_type() const {
    return static_cast<Data>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const Auth1 *data_as_Auth1() const {
    return data_type() == Data_Auth1 ? static_cast<const Auth1 *>(data()) : nullptr;
  }
  const AuthAck1 *data_as_AuthAck1() const {
    return data_type() == Data_AuthAck1 ? static_cast<const AuthAck1 *>(data()) : nullptr;
  }
  const Auth2 *data_as_Auth2() const {
    return data_type() == Data_Auth2 ? static_cast<const Auth2 *>(data()) : nullptr;
  }
  const AuthAck2 *data_as_AuthAck2() const {
    return data_type() == Data_AuthAck2 ? static_cast<const AuthAck2 *>(data()) : nullptr;
  }
  const Stats *data_as_Stats() const {
    return data_type() == Data_Stats ? static_cast<const Stats *>(data()) : nullptr;
  }
  const StatsAck *data_as_StatsAck() const {
    return data_type() == Data_StatsAck ? static_cast<const StatsAck *>(data()) : nullptr;
  }
  const Alloc *data_as_Alloc() const {
    return data_type() == Data_Alloc ? static_cast<const Alloc *>(data()) : nullptr;
  }
  const AllocAck *data_as_AllocAck() const {
    return data_type() == Data_AllocAck ? static_cast<const AllocAck *>(data()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyData(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Auth1 *AllocatorMessage::data_as<Auth1>() const {
  return data_as_Auth1();
}

template<> inline const AuthAck1 *AllocatorMessage::data_as<AuthAck1>() const {
  return data_as_AuthAck1();
}

template<> inline const Auth2 *AllocatorMessage::data_as<Auth2>() const {
  return data_as_Auth2();
}

template<> inline const AuthAck2 *AllocatorMessage::data_as<AuthAck2>() const {
  return data_as_AuthAck2();
}

template<> inline const Stats *AllocatorMessage::data_as<Stats>() const {
  return data_as_Stats();
}

template<> inline const StatsAck *AllocatorMessage::data_as<StatsAck>() const {
  return data_as_StatsAck();
}

template<> inline const Alloc *AllocatorMessage::data_as<Alloc>() const {
  return data_as_Alloc();
}

template<> inline const AllocAck *AllocatorMessage::data_as<AllocAck>() const {
  return data_as_AllocAck();
}

struct AllocatorMessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(AllocatorMessage::VT_ID, id, 0);
  }
  void add_data_type(Data data_type) {
    fbb_.AddElement<uint8_t>(AllocatorMessage::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(flatbuffers::Offset<void> data) {
    fbb_.AddOffset(AllocatorMessage::VT_DATA, data);
  }
  AllocatorMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AllocatorMessageBuilder &operator=(const AllocatorMessageBuilder &);
  flatbuffers::Offset<AllocatorMessage> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<AllocatorMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<AllocatorMessage> CreateAllocatorMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    Data data_type = Data_NONE,
    flatbuffers::Offset<void> data = 0) {
  AllocatorMessageBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_id(id);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline bool VerifyData(flatbuffers::Verifier &verifier, const void *obj, Data type) {
  switch (type) {
    case Data_NONE: {
      return true;
    }
    case Data_Auth1: {
      auto ptr = reinterpret_cast<const Auth1 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data_AuthAck1: {
      auto ptr = reinterpret_cast<const AuthAck1 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data_Auth2: {
      auto ptr = reinterpret_cast<const Auth2 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data_AuthAck2: {
      auto ptr = reinterpret_cast<const AuthAck2 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data_Stats: {
      auto ptr = reinterpret_cast<const Stats *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data_StatsAck: {
      auto ptr = reinterpret_cast<const StatsAck *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data_Alloc: {
      auto ptr = reinterpret_cast<const Alloc *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Data_AllocAck: {
      auto ptr = reinterpret_cast<const AllocAck *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyDataVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyData(
        verifier,  values->Get(i), types->GetEnum<Data>(i))) {
      return false;
    }
  }
  return true;
}

inline const cirrus::message::AllocatorMessage::AllocatorMessage *GetAllocatorMessage(const void *buf) {
  return flatbuffers::GetRoot<cirrus::message::AllocatorMessage::AllocatorMessage>(buf);
}

inline bool VerifyAllocatorMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<cirrus::message::AllocatorMessage::AllocatorMessage>(nullptr);
}

inline void FinishAllocatorMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<cirrus::message::AllocatorMessage::AllocatorMessage> root) {
  fbb.Finish(root);
}

}  // namespace AllocatorMessage
}  // namespace message
}  // namespace cirrus

#endif  // FLATBUFFERS_GENERATED_ALLOCATORMESSAGE_CIRRUS_MESSAGE_ALLOCATORMESSAGE_H_
